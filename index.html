<!DOCTYPE html>
<html lang="it">

<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>HTML5 Fitts' Law Task</title>
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.20/lodash.min.js"></script>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <link rel="stylesheet" href="css/style.css" />
</head>

<body>
  <div class="container">
    <div class="fitts-area">
      <div id="test-area" class="sans"></div>
    </div>
    
    <div class="result" id="complete-area" style="display:none;">
      <h2>Dati salvati con successo...</h2>
      <p>Grazie per aver partecipato!</p>
    </div>

    <div class="result" id="incomplete-area" style="display:none;color:#f00;">
      <p><strong>C'è stato un problema nel salvataggio dei dati.</strong></p>
      <button id="retry-submit">Riprova</button>
    </div>
  </div>

  <script>
    "use strict";

    // --- VARIABILI GLOBALI ---
    var user = guid();
    var clickcount = 0;
    var currentCondition = 0;
    var fittsTest, testAreaSVG;
    var experimentStarted = false; // Flag per gestire l'avvio
    
    // Valori costanti
    var LIVE_STAY = 1000;
    var MAX_TIME = 2000;
    var UPDATE_DELAY = MAX_TIME;
    var MAX_SPEED = 1;
    
    // Variabili che verranno ricalcolate dopo il fullscreen
    var testDimension;
    var conditions;


    // --- FUNZIONI DI BASE ---
    function makeDimension(width, height, top, right, bottom, left) {
      return {
        width: width, height: height,
        innerWidth: width - (left + right), innerHeight: height - (top + bottom),
        top: top, right: right, bottom: bottom, left: left,
        cx: (width - (left + right)) / 2 + left,
        cy: (height - (top + bottom)) / 2 + top
      };
    }
    
    function initializeDimensionsAndConditions() {
        // Ricalcola le dimensioni basandosi sulla finestra corrente (che sarà fullscreen)
        testDimension = makeDimension(
            window.innerWidth * 0.9, window.innerHeight * 0.8, 30, 30, 30, 30
        );

        // Ricalcola le condizioni del test con le nuove dimensioni
        conditions = _.shuffle([
            { width: testDimension.innerWidth * 0.04, distance: testDimension.innerWidth * 0.35, type: 'experimental' },
            { width: testDimension.innerWidth * 0.06, distance: testDimension.innerWidth * 0.35, type: 'experimental' },
            { width: testDimension.innerWidth * 0.04, distance: testDimension.innerWidth * 0.42, type: 'experimental' },
            { width: testDimension.innerWidth * 0.06, distance: testDimension.innerWidth * 0.42, type: 'experimental' }
        ]);
        conditions.unshift({ width: testDimension.innerWidth * 0.07, distance: testDimension.innerWidth * 0.25, type: 'training' });
    }

    // --- LOGICA DI AVVIO ---
    $(document).ready(function () {
      $('#retry-submit').click(function () { sendData(); });
      
      // Calcola le dimensioni iniziali solo per disegnare l'area
      initializeDimensionsAndConditions(); 
      doD3Setup();
      drawStartTrial(); // Disegna il primo pallino centrale per iniziare
    });

    function drawStartTrial() {
        testAreaSVG.append('circle')
            .attr('id', 'start-target')
            .attr('cx', testDimension.cx)
            .attr('cy', testDimension.cy)
            .attr('r', testDimension.innerWidth * 0.035) // Dimensione del pallino iniziale
            .style('fill', 'red');
    }

    function startExperiment() {
        experimentStarted = true;
        $('#start-target').remove(); // Rimuove il pallino di avvio

        // Ricalcola tutto dopo essere entrati in fullscreen
        initializeDimensionsAndConditions();
        
        // Aggiorna le dimensioni dell'SVG
        d3.select("#test-area svg")
            .attr("width", testDimension.width)
            .attr("height", testDimension.height);
        
        // Ora inizializza e avvia il test vero e proprio
        fittsTest = FittsTest();
        fittsTest.updateISOCircles();
        fittsTest.addDataSet();
    }


    /* ----------------------------
        Oggetto Test di Fitts
    -----------------------------*/
    function FittsTest() {
      return {
        target: { x: 0, y: 0, r: 10 }, start: { x: 0, y: 0, t: 0 }, last: {}, isoPositions: [],
        currentPosition: 0, currentCount: 0, miss: 0,
        isoParams: { num: 9, distance: conditions[currentCondition].distance, width: conditions[currentCondition].width },
        currentPath: [], active: false, data: [], currentDataSet: 0, dataCnt: 0, updateTimeoutHandle: undefined,

        generateTarget: function () {
          this.target = this.isoPositions[this.currentPosition];
          this.target.distance = this.isoParams.distance;
          this.currentPosition = (this.currentPosition + Math.ceil(this.isoPositions.length / 2)) % this.isoPositions.length;
          var target = testAreaSVG.selectAll('#target').data([this.target]);
          var insert = function (d) { d.attr('cx', d => d.x).attr('cy', d => d.y).attr('r', d => d.w / 2); }
          target.enter().append('circle').attr('id', 'target').style('fill', 'red').call(insert);
          target.transition().call(insert);
        },

        updateISOCircles: function () {
          this.currentCount = 0;
          this.generateISOPositions(this.isoParams.num, this.isoParams.distance, this.isoParams.width);
          var circles = testAreaSVG.selectAll('circle').data(this.isoPositions);
          var insert = function (d) { d.attr('cx', d => d.x).attr('cy', d => d.y).attr('r', d => d.w / 2); }
          circles.enter().append('circle').attr('class', 'iso').call(insert);
          circles.transition().call(insert);
          circles.exit().transition().attr('r', 0).remove();
          this.currentPosition = 0;
          this.generateTarget();
        },

        generateISOPositions: function (num, d, w) {
          this.isoPositions = [];
          for (var i = 0; i < num; i++) {
            this.isoPositions[i] = {
              x: testDimension.cx + ((d / 2) * Math.cos((2 * Math.PI * i) / num)),
              y: testDimension.cy + ((d / 2) * Math.sin((2 * Math.PI * i) / num)),
              w: w
            };
          }
        },

        removeTarget: function () { testAreaSVG.selectAll('#target').data([]).exit().remove(); this.currentPath = []; },

        mouseClicked: function (x, y) {
          if (distance({ x: x, y: y }, this.target) < (this.target.w / 2)) {
            this.addDataPoint({
              start: this.start, target: this.target, path: this.currentPath,
              hit: { x: x, y: y, t: (new Date).getTime() }
            });
            this.removeTarget(); this.currentCount++; this.generateTarget();
            this.last = { x: x, y: y, t: (new Date).getTime() };
            this.start = this.last; this.currentPath.push(this.last);
          } else { this.miss++; }
        },

        mouseMoved: function (x, y) {
          if (this.active) {
            if (x == this.last.x && y == this.last.y) return;
            if (this.updateTimeoutHandle) window.clearTimeout(this.updateTimeoutHandle);
            this.updateTimeoutHandle = window.setTimeout(this.updatePlots, UPDATE_DELAY, this);
            var newPoint = { x: x, y: y, t: (new Date).getTime() }
            this.currentPath.push(newPoint)
            var dt = newPoint.t - this.last.t;
            var dist = distance(this.last, { x: x, y: y });
            var speed = dt > 0 ? dist / dt : 0;
            testAreaSVG.append('line').attr('class', 'trace')
              .attr('x1', this.last.x).attr('x2', newPoint.x).attr('y1', this.last.y).attr('y2', newPoint.y)
              .style('stroke', v(speed)).transition().duration(5000).style('stroke-opacity', 0).remove();
            this.last = newPoint;
          }
        },

        addDataPoint: function (data) {
          if (this.active == false) { this.active = true; return; }
          var dt = data.hit.t - data.start.t;
          if (dt < MAX_TIME) {
            clickcount += 1;
            var clickError = distance({ x: data.hit.x, y: data.hit.y }, { x: data.target.x, y: data.target.y });
            this.data[this.currentDataSet].data.push({
              time: dt, distance: data.target.distance, width: data.target.w, type: conditions[currentCondition].type,
              conditionOrder: currentCondition, clickX: data.hit.x, clickY: data.hit.y,
              targetX: data.target.x, targetY: data.target.y, clickError: clickError
            });
          }
          if (clickcount === 10) {
            if (currentCondition === conditions.length - 1) {
              $('.fitts-area').remove(); sendData();
            } else {
              $('.trace').remove(); clickcount = 0; currentCondition += 1;
              this.isoParams.width = conditions[currentCondition].width;
              this.isoParams.distance = conditions[currentCondition].distance;
              this.updateISOCircles(); this.active = false;
            }
          }
        },

        addDataSet: function () { this.dataCnt++; this.data[this.dataCnt] = { data: [] }; this.currentDataSet = this.dataCnt; }
      }
    };

    /* ----------------------------
        Funzioni Mouse e Helper
    -----------------------------*/
    function mouseMoved() {
      if (!experimentStarted) return;
      var m = d3.mouse(this);
      fittsTest.mouseMoved(m[0], m[1]);
    }

    function mouseClicked() {
        var m = d3.mouse(this);
        if (!experimentStarted) {
            // Questo è il primo click, sul pallino di avvio
            var startTarget = d3.select('#start-target');
            var r = parseFloat(startTarget.attr('r'));
            var cx = parseFloat(startTarget.attr('cx'));
            var cy = parseFloat(startTarget.attr('cy'));
            if (distance({x: m[0], y: m[1]}, {x: cx, y: cy}) < r) {
                openFullscreen();
                // Aspettiamo un istante per permettere al browser di entrare in fullscreen
                // prima di ricalcolare le dimensioni e avviare il test.
                setTimeout(startExperiment, 500); 
            }
        } else {
            // L'esperimento è già iniziato, gestisci i click normalmente
            fittsTest.mouseClicked(m[0], m[1]);
        }
    }

    function distance(a, b) { var dx = a.x - b.x, dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); }
    function clampInt(lower, upper, x) { return Math.min(upper, Math.max(lower, Math.floor(x))); }
    function guid() { function s4() { return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); } return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4(); }
    function v(v) { return 'rgb(0,0,' + clampInt(0, 255, (v / MAX_SPEED) * 255) + ')'; }

    /* ----------------------------
        Salvataggio Dati e Fine
    -----------------------------*/
    function sendData() {
      var participant = user;
      var allData = [];
      for (var i = 1; i <= fittsTest.dataCnt; i++) { allData = allData.concat(fittsTest.data[i].data); }
      var csvData = '"Participant","Type","ConditionOrder","Width","Distance","Time","ClickX","ClickY","TargetX","TargetY","ClickError"\n';
      allData.forEach(function (trial) {
        csvData += `"${participant}","${trial.type}","${trial.conditionOrder}","${trial.width}","${trial.distance}","${trial.time}","${trial.clickX}","${trial.clickY}","${trial.targetX}","${trial.targetY}","${trial.clickError}"\n`;
      });
      var blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
      var link = document.createElement("a");
      if (link.download !== undefined) {
        var url = URL.createObjectURL(blob);
        link.setAttribute("href", url); link.setAttribute("download", "fitts_law_data.csv");
        link.style.visibility = "hidden"; document.body.appendChild(link);
        link.click(); document.body.removeChild(link);
      }
      $("#complete-area").show();
      exitFullscreen(); // Esci dal fullscreen alla fine
    }

    /* ----------------------------
        Setup Iniziale e Fullscreen
    -----------------------------*/
    function doD3Setup() {
      testAreaSVG = d3.select('#test-area').append('svg')
        .attr('width', testDimension.width).attr('height', testDimension.height)
        .style('pointer-events', 'all')
        .on('mousemove', mouseMoved)
        .on('mousedown', mouseClicked)
        .call(d => d.append('rect').attr('width', testDimension.width).attr('height', testDimension.height).attr('class', 'back'));
    }
    
    function openFullscreen() {
      let el = document.documentElement;
      if (el.requestFullscreen) { el.requestFullscreen(); } 
      else if (el.webkitRequestFullscreen) { el.webkitRequestFullscreen(); } 
      else if (el.msRequestFullscreen) { el.msRequestFullscreen(); }
    }

    function exitFullscreen() {
      if (document.exitFullscreen) { document.exitFullscreen(); } 
      else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); } 
      else if (document.msExitFullscreen) { document.msExitFullscreen(); }
    }
  </script>
</body>
</html>
